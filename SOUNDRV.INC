;ISCOM           equ     1
;ISEXE           equ     0

DIG_ADLIB       =       0       ; Build 1
DIG_CVXSND      =       0       ; Build 2
DIG_VMSND       =       0       ; Build 3
DIG_SMSND       =       0       ; Build 4
DIG_IBMSND      =       0       ; Build 5
DIG_DIGISP      =       0       ; Build 6
DIG_TANEXTX     =       0       ; Build 7
DIG_TANSLTL     =       0       ; Build 8
DIG_SBLASTER    =       0       ; Build 9
DIG_SOURCE      =       0       ; Build 10
DIG_ECHOII      =       0       ; Build 11
DIG_LANTSND     =       0       ; Build 12
DIG_IBMBAK      =       0       ; Build 13
DIG_IBM1BIT     =       0       ; Build 14
DIG_PAUDIO      =       0       ; Build 15
DIG_BIGMOUTH    =       0       ; Build 16
DIG_MASTER      =       0       ; BUild 17
DIG_ADLIBG      =       0       ; Build 18
DIG_T2500       =       0       ; Build 19
DIG_ARIA        =       0       ; Build 20

BACKFILL        =       0       ; DMA backfill support is 0 by default.

MILLIKEN        equ     0

PLAYBACK        equ     1       ;0
MASSAGE         equ     2       ;1
FIXEDFREQ       equ     4       ;2
USESTIMER       equ     8       ;3
SHARESTIMER     equ     16      ;4 True if supports timer sharing.
LOOPEND         equ     32      ;5 Supports looping,and pending sounds.
STEREOPAN       equ     64      ;6 supports stereo panning.
STEREOPLAY      equ     128     ;7 Supports stereo playback!
AUDIORECORD     equ     256     ;8 support digital sound recording.
DMABACKFILL     equ     512     ;9 supports DMA backfilling.
PCM16           equ     1024    ;10 supports 16 bit PCM!
PCM16STEREO     equ     2048    ;11 supports 16 bit Stereo PCM!


TIMER0          equ     40h     ; port address of timer 0
portTIMER2      equ     42h     ; port address of timer 2
TIME_CNTRL      equ     43h     ; 8253 control register port

SOUNDSPEC	Struc	
PLAYADR FARPTR  <>              ; Address of sound sample to be played.
PLAYLEN         dw      ?       ; Length of sound sample to be played.
ISPLAYING FARPTR <>             ; Address of our playing sample semephore.
FREQUENCY       dw      ?       ; Frequency to play it at.
SOUNDSPEC	Ends

IN_TSR	Macro
	push	ds
	push	es
	push	si
	push	di
	mov	ax,cs
	mov	ds,ax
	mov	es,ax
	endm

OUT_TSR	Macro	
	pop	di
	pop	si
	pop	es
	pop	ds
	endm

WaitSound	Macro	
	LOCAL	@@WT
@@WT:	mov	ax,689h
	int	66h
	or	ax,ax
	jnz	@@WT
	endm

Dally	Macro	
	jmp	$+2
	endm

PCM_8_MONO      equ     0
PCM_8_STEREO    equ     1
PCM_16_MONO     equ     2
PCM_16_STEREO   equ     3

;; Set's the DIGPAK semaphore
SetSemaphore	Macro	
	mov	[cs:INDIGPAK],1
	endm

;; Clear's the semaphore, and does an IRET
ClearSemaphoreIRET	Macro	
	mov	[cs:INDIGPAK],0
	iret
	endm

ClearSemaphore	Macro	
	mov	[cs:INDIGPAK],0
	endm

;; This macro checks the DPMI compliant FLAG
;;  If DPMI is on, then the address of the SoundStructure passed is
;;  in ESI instead of DS:SI.  First make certain it is in the low 1mb
;;  of address space.  If not, clearsemaphoreiret.  Otherwise set DS:SI
;;  equal to that address.
ConvertDPMI Macro myseg,indx
	LOCAL	@@HOP
	cmp	[cs:DPMI],0	; In 32 bit DPMI mode?
	je	@@HOP
	push	eax		; Save EAX
	mov	eax,indx	; Get the entire 32 bit flat-model address.
	shr	eax,4		; leave just the segment portion.
	mov	myseg,ax		 ; place the segment into DS
	and	indx,0Fh	 ; leave just the offset portion.
	pop	eax
@@HOP:
	endm

GET20BIT Macro  	
	call	makelinear
;;;    PUSH   CX
;;;    MOV    CL,4
;;;    ROL    DX,CL
;;;    MOV    CX,DX
;;;    AND    DX,0FH
;;;    XOR    CX,DX
;;;    ADD    AX,CX
;;;    ADC    DX,0
;;;    POP    CX
       endm

KINT    equ     66h

